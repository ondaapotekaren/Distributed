# FEEL FREE TO CHANGE THE CODE. 
# This is just a dull example
# ------------------------------------------------------------------------------   

# ------------------------------------------------------------------------------
# History strucure
# "ADD", (entry), entryID, author, seq_number 
# "DELETE", (entry), entryID, author, seq_number
# "MODIFY", (newEntry, oldEntry), entryID, author, seq_number
# ------------------------------------------------------------------------------ 

# ------------------------------------------------------------------------------   
# Start listening and handle incoming connections in board() function
# Also star leader election after 5 second 
# ------------------------------------------------------------------------------   

def start_board():
  ip = mycontext['ip']
  port = mycontext['port']
  print "Listening on IP " + str(ip) +" port " + str(port)
  try:   
    listencommhandle = waitforconn(ip, port, board_connection_handler)  
  except Exception, e:
    print "Exception in start_board: %s, %s\n" %(type(e), e)
    raise

# ------------------------------------------------------------------------------    
# Called when an incoming message is received. 
# --> Important starting point
# ------------------------------------------------------------------------------    
def board_connection_handler(ip, port, sockobj, thiscommhandle, listencommhandle):
  try:
    msgheader = sockobj.recv(1024) # Receive message
    print '****Request:\n%s' % msgheader
    # React depending on message type: HTTP GET or POST, or some other type of communication.
    #----From the browser----
    if msgheader.startswith( 'GET' ):
      get_board_handler(msgheader, sockobj, thiscommhandle)    

    #----Add entry(sent from browser)----
    elif msgheader.startswith( 'POST /board' ):
      query = extract_http_request_contents(msgheader)
      parameters = extract_parameters_from_query(query)
      mycontext['id'] = mycontext['id'] + 1 
      add_entry(parameters['entry'],mycontext['id'])
      mycontext['vector_clock'][mycontext['identifier']] = mycontext['vector_clock'][mycontext['identifier']] + 1
      mycontext['history'].append(("ADD", (parameters['entry']), mycontext['id'],mycontext['identifier'],mycontext['vector_clock'][mycontext['identifier']]))
      send_to_vessels(parameters['entry'],mycontext['id'],"ADD",3)
      res=make_http_response(200,'OK','')
      sockobj.send(res)
      stopcomm(thiscommhandle)
      
    #----Delete or Modify entry(sent from browser)---- 
    elif msgheader.startswith( 'POST /entries' ):
      query = extract_http_request_contents(msgheader)
      parameters = extract_parameters_from_query(query)
      entryID = msgheader.split('/')[2].split(' ')[0]
      mycontext['vector_clock'][mycontext['identifier']] = mycontext['vector_clock'][mycontext['identifier']] + 1
      #----Delete or modify entry on the board if leader, otherwise send message to leader
      if parameters['delete']==str(1):
      	mycontext['history'].append(("DELETE", (get_entry(entryID)), int(entryID),mycontext['identifier'],mycontext['vector_clock'][mycontext['identifier']] ))
        delete_entry(entryID)
        send_to_vessels("", entryID, "DELETE",3)
      elif parameters['delete']==str(0): 
        mycontext['history'].append(("MODIFY", (parameters['entry'],get_entry(entryID)), entryID,mycontext['identifier'], mycontext['vector_clock'][mycontext['identifier']]))
        modify_entry(parameters['entry'], entryID)
        send_to_vessels(parameters['entry'], entryID, "MODIFY",3)
      res = make_http_response(200,'OK','')
      sockobj.send(res)
      stopcomm(thiscommhandle)

     #----Receive add from vessels and update board----  
    elif msgheader.startswith( 'POST /neighbour/entries' ):
      query = extract_http_request_contents(msgheader)
      parameters = extract_parameters_from_query(query)
      entry=parameters['entry']
      entryID=int(parameters['entryID'])
      sendclock = int(parameters['sendclock']) 
      recclock = int(parameters['recclock'])
      vid=parameters['vid'] #also used as prio check
      print parameters['vectorclock'] 
      tempdic = format_vector(parameters['vectorclock'])
      syncval = check_clock(tempdic,mycontext['vector_clock']) 
      print syncval
      if syncval[1] > 0:
        print syncval[1]
        #rollback syncval[1] entries
      if syncval[0] > 1:
        print syncval[0]
        #request history of size syncval[0]
        #vid, syncval[0], 
      if not is_double(vid, sendclock):
        print "is not double"
      if syncval[0]==1 and syncval[1]==0:
        #everything is fine
        mycontext['history'].append(("ADD", (entry), entryID, vid, mycontext['vector_clock'][vid]))
        mycontext['id'] = mycontext['id'] + 1
        add_entry(entry, mycontext['id'])
        mycontext['vector_clock'][vid] = mycontext['vector_clock'][vid] + 1 
      #clocks are synced
      #check so that clocks are correct 
        #if mycontext['vector_clock'][vid] + 1 == sendclock and mycontext['vector_clock'][mycontext['identifier']] == recclock:
          #mycontext['vector_clock'][mycontext['identifier']] = mycontext['vector_clock'][mycontext['identifier']] + 1
          #mycontext['vector_clock'][vid] = mycontext['vector_clock'][vid] + 1 
          #mycontext['id'] = mycontext['id'] + 1
          #add_entry(entry, mycontext['id'])
          #mycontext['history'].append(("ADD", (entry), entryID, vid, mycontext['vector_clock'][sendclock])) 
        #elif sendclock < (mycontext['lclock'] +1):
          #print "sender out of sync"
          #send_history()
        #elif sendclock > (mycontext['lclock'] +1):
          #print "im out of sync"
        #request_history()

    #----Receive delete from vessels and update board-----
    elif msgheader.startswith( 'POST /neighbour/delete' ):
      query = extract_http_request_contents(msgheader)
      parameters = extract_parameters_from_query(query)
      entryID = int(parameters['entryID'])
      sendclock = int(parameters['sendclock']) 
      recclock = int(parameters['recclock'])
      vid=parameters['vid'] #also used as prio check
    
      if not is_double(vid, sendclock):
	if mycontext['vector_clock'][vid] + 1 == sendclock and mycontext['vector_clock'][mycontext['identifier']] == recclock:
	  mycontext['vector_clock'][mycontext['identifier']] = mycontext['vector_clock'][mycontext['identifier']] + 1
	  mycontext['vector_clock'][vid] = mycontext['vector_clock'][vid] + 1
	  mycontext['history'].append(("DELETE", (get_entry(entryID)), entryID, vid, mycontext['vector_clock'][sendclock]))
	  delete_entry(parameters['entryID'])
	elif sendclock < (mycontext['lclock'] +1):
	  print "sender out of sync"
	  #send_history()
	elif sendclock > (mycontext['lclock'] +1):
	  print "im out of sync"
	  #request_history()

    #----Receive modify from vessels and update board-----
    elif msgheader.startswith( 'POST /neighbour/modify' ):
      query = extract_http_request_contents(msgheader)
      parameters = extract_parameters_from_query(query)
      entry=parameters['entry']
      entryID=int(parameters['entryID'])
      sendclock = int(parameters['sendclock']) 
      recclock = int(parameters['recclock'])
      vid=parameters['vid'] #also used as prio check

      if not is_double(vid, sendclock):
	if mycontext['vector_clock'][vid] + 1 == sendclock and mycontext['vector_clock'][mycontext['identifier']] == recclock:
	  mycontext['vector_clock'][mycontext['identifier']] = mycontext['vector_clock'][mycontext['identifier']] + 1
	  mycontext['vector_clock'][vid] = mycontext['vector_clock'][vid] + 1
	  mycontext['history'].append(("MODIFY", (entry,get_entry(entryID)), entryID, vid, mycontext['vector_clock'][sendclock]))
	  modify_entry(entry, entryID)
	elif sendclock < (mycontext['lclock'] +1):
	  print "sender out of sync"
	  #send_history()
	elif sendclock > (mycontext['lclock'] +1):
	  print "im out of sync"
	  #request_history()

    #----DEBUG--------------------------------------------
    elif msgheader.startswith( 'DEBUG' ):
      print "-----------DEBUG------------"
      query = extract_http_request_contents(msgheader)
      parameters = extract_parameters_from_query(query)
      rollback(int(parameters['debug']),1)

    else:
      other_requests_handler(msgheader, sockobj, thiscommhandle)

  except Exception, e:
    print "Exception in board: %s, %s\n" %(type(e), e)

# ------------------------------------------------------------------------------
# Checks if incoming message is a already in history
# ------------------------------------------------------------------------------
def is_double(author, seqnum):
  for msg in mycontext['history']:
    if author == msg[3] and seqnum == msg[4]:
      print "double detected"
      return True
  return False


# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def get_board_handler(msgheader, sockobj, thiscommhandle):
  htmlresponse = generate_html_page()
  res=make_http_response(200, 'OK', htmlresponse)
  sockobj.send(res)
  stopcomm(thiscommhandle) 

# ------------------------------------------------------------------------------
# Update entries on the board from entries with seqnumber entryID and upwards 
# --------------------------------------------------------------------------

def update_board(entryID):
  if entryID == 1:
    mycontext['entries']=""
  if(entryID <= mycontext['id']):
    if(mycontext['idhash'].has_key(entryID)):
      entryFormat  = mycontext['entry_template'] %('entries/%d' % (entryID), entryID, mycontext['idhash'][entryID]) 
      mycontext['entries'] = ''.join( [ mycontext['entries'], entryFormat] )
    update_board(entryID+1)

# ------------------------------------------------------------------------------
# Add entries to hash then call update 
# if we want to update id, don't do it here 
# also probably don't update clock here 
# ---------------------------------------------------------------------------
def add_entry(entry,entryID): 
  mycontext['idhash'][int(entryID)]= entry 
  update_board(int(entryID))

# ------------------------------------------------------------------------------
# Delete entries from hash then call update
# also probably don't update clock here 
# ---------------------------------------------------------------------------
def delete_entry(entryID):
  if mycontext['idhash'].has_key(int(entryID)):
    entry = get_entry(entryID)
    del mycontext['idhash'][int(entryID)]
    update_board(1)

# ------------------------------------------------------------------------------
# Modify entries in the hash then call update
# also probably don't update clock here  
# --------------------------------------------------------------------------
def modify_entry(entry,entryID):
  mycontext['idhash'][int(entryID)] = entry
  update_board(1)

# ------------------------------------------------------------------------------
# Get entries 
# --------------------------------------------------------------------------
def get_entry(entryID): 
	return mycontext['idhash'][int(entryID)]

# ------------------------------------------------------------------------------
# Update entries recursively   
# --------------------------------------------------------------------------
def update_entry(entry,entryID):
	if(entryID <= mycontext['id']):
		moveEntry = get_entry(entryID)
		modify_entry(entry,entryID)
		update_entry(moveEntry,entryID+1) 
	else:
		mycontext['id'] = mycontext['id']+1
		add_entry(entry,mycontext['id'])
# ------------------------------------------------------------------------------
# merge shit, pop rollback history 
# ------------------------------------------------------------------------------
def merge_history(remote_history,rollback_history):
  return

# ------------------------------------------------------------------------------
# compare vectorclocks to see rollback and history size 
# -----------------------------------------------------------------------------
def check_clock(in_clock,our_clock):
  historySize = 0
  rollbackSize = 0 
  for key in our_clock: 
    size = in_clock[key]-our_clock[key]
    if(size>0):
      historySize = historySize + size  
    elif(size<0):
      rollbackSize = rollbackSize + size*(-1)
  return (historySize,rollbackSize)

# ------------------------------------------------------------------------------
# Format 
# ---------------------------------------------------------------------------- 
def format_vector(string):
  vectordict = {}
  formatstring = (" " + string[1:-1]).split(',')
  for pair in formatstring:
     key = pair.split(':')[0][2:-1]
     value = pair.split(':')[1][1:]
     vectordict[key] = int(value)
  return vectordict    

# ------------------------------------------------------------------------------
# Rollback history as many times as specified by the argument lag 
# return pop history
# use history in merge_history 
# ------------------------------------------------------------------------------
def rollback(lag,num):
  print "----------ROLLBACK------------"
  print "history: "
  print mycontext['history']
  lastupdate = mycontext['history'][-num]
  if lag != 0:
    if lastupdate[0] == "ADD":
      delete_entry(lastupdate[2])
    elif lastupdate[0] == "DELETE": 
      add_entry(lastupdate[1],lastupdate[2])
    elif lastupdate[0]=="MODIFY":
      modify_entry(lastupdate[1][1],lastupdate[2])
    rollback(lag-1,num+1)     
  else:
    update_board(1)

# ------------------------------------------------------------------------------
# Send message to other vessels. Try as many times as specified by testnmbr
# ----------------------------------------------------------------------------  



# ------------------------------------------------------------------------------
# Send message to other vessels. Try as many times as specified by testnmbr
# ----------------------------------------------------------------------------  

def send_to_vessels(entry,entryID,action,testnmbr):
  for sock in mycontext['vessels']:
    send_to_vessel(entry,entryID,action,testnmbr,sock)

def send_to_vessel(entry,entryID,action,testnmbr,sock):
  try:
    if mycontext['global']:
      sendID = sock[0]
    else: 
      sendID = sock[1] 

    http_res = make_http_response(200,'OK', "entry="+entry+"&entryID="+str(entryID)+"&vid="
                                   +mycontext['identifier']+"&sendclock="+str(mycontext['vector_clock'][mycontext['identifier']])
                                   +"&recclock="+str(mycontext['vector_clock'][sendID])+"&vectorclock="+str(mycontext['vector_clock']))
    
    if action == "ADD": 
      socketobject = openconn(sock[0],int(sock[1]))
      send_object = 'POST /neighbour/entries ' + http_res
    elif action == "DELETE":   
      socketobject = openconn(sock[0],int(sock[1]))
      #http_res = make_http_response(200,'OK',"entryID="+str(entryID)+"&clock="+	str(mycontext['lclock']))
      send_object = 'POST /neighbour/delete ' + http_res
    elif action == "MODIFY":
      socketobject = openconn(sock[0],int(sock[1]))
      #http_res = make_http_response(200, 'OK',"entry="+entry+"&entryID="+str(entryID)+"&clock="+str(mycontext['lclock']))
      send_object = 'POST /neighbour/modify' + http_res 
    socketobject.send(send_object)
    socketobject.close()
  except:
    if(testnmbr != 0):
      send_to_vessel(entry,entryID,action,testnmbr-1,sock)
    else:
      if mycontext['global']:
        print "error in connection to vessel: " + sock[0]
      else:
        print "error in connection to vessel: " + sock[1]

# ------------------------------------------------------------------------------
# Sends history to vessels out of sync
# ------------------------------------------------------------------------------
# if someone behind add to history and sen history
def send_history(vessel, lag):
  if lag > 20:
    #send_board()
    return
  else:
    if mycontext['global']:
      socketobject = openconn(vessel,int(mycontext['port']))
    else:
      socketobject = openconn(mycontext['ip'],vessel)
    send_list = mycontext['history'][-lag:]
    for action in send_list:
      send_to_vessel(action[0], action[1], action[2], 3, ())
# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def other_requests_handler(msgheader, sockobj, thiscommhandle):
  # extract the query from the HTTP request  
  query = extract_http_request_contents(msgheader)
  print query
  # extract the query parameters
  parameters = extract_parameters_from_query(query)
  print parameters
  print parameters['entry']
  
  # Do not mix HTML code with the server code as done here. This is a bad practice
  template=file("no_answer_template.html").read()
  htmlresponse = template % ("404 Not Found\n" + msgheader)
  res=make_http_response(404, 'Not Found', htmlresponse)
  sockobj.send(res)
  stopcomm(thiscommhandle) 

# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_response(status, status_text, htmlresponse):
    response_template = "HTTP/1.1 %d %s\r\nContent-type: text/html\r\nContent-Length: %i\r\n\r\n%s"
    return response_template % (status, status_text, len(htmlresponse), htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
  # find content length
  conent_length = header.split('Content-Length: ')[1]
  conent_length = int(conent_length.split('\r\n')[0])
  
  # extract the http response body and discard the header
  contetns = header[-conent_length:]
  return contetns

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
  # extract the query parameters as a dictionary: {name:value}
  # example input format: comment=aa&ip=127.0.0.1&port=63101&action=Delete
  parameters={}
  arr = msg.split('&')
  for a in arr:
    pp = a.split('=')
    if len(pp)>1:
      parameters[pp[0]] = pp[1]
  return parameters

# ------------------------------------------------------------------------------
# Outputs the blackboard html 
# ------------------------------------------------------------------------------   
def generate_html_page():
  
  # dynamic title showing Ip address, port and up time. 
  title='Sample board @ %s:%d. Up time: %d' %( str(mycontext['ip']), mycontext['port'], int(getruntime()))
  content = mycontext['boardcontents_template'] %( title, mycontext['entries'] )
  content += str(mycontext['vector_clock'])
  fullpage_h = mycontext['frontpage_header_template'] + content
  fullpage = fullpage_h + mycontext['frontpage_footer_template'] % mycontext['authors']
  #print entries, content, fullpage
  return fullpage
  
# ------------------------------------------------------------------------------    
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens a socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
  # whenever this vessel gets a connection on its IP:port it'll call function board_connection_handler
  if len(callargs) == 1 or len(callargs) == 2:
    port = int(callargs[0])
    if len(callargs) == 2:
      ip=str(callargs[1])
    else:
      try:
        ip = getmyip()
      except Exception, e:
        print "Could not get an IP\n"
        print (type(e), e)
        raise
  
  # Fail if we don't have 1 or 2 arguments  
  else:
    raise Exception("Usage: python <path to repy.py> <path to restrictions.default> skeleton2016.repy <port> [ip (optional)]")
  
  #Global variable for entries
  mycontext['entries'] = ""
  
  #Count entries 
  mycontext['id'] = 0
  
  #Vessels on the same network
  idhash = {}
  mycontext['idhash'] = idhash 

  # Other vessels to send to 
  mycontext['vessels'] = []

  # Ring-topology for electing leader 
  vector_clock = {}
  mycontext['vector_clock'] = vector_clock

  mycontext['random'] = int(10000*randomfloat())
  mycontext['stoplock'] = getlock()

	# Logical clock
  mycontext['lclock'] = 0

  # Used to simplify global/local testing 
  mycontext['global'] = False

  #Initialize Port and IP
  mycontext['port'] = port
  mycontext['ip'] = ip

  #Either unique port or ip-address
  mycontext['identifier']=''

  #List for local history
  mycontext['history'] = []


	#Read ports(locally) or ip-addresses(globally)
	#from a file
  if mycontext['global']:
    vessels = file("neighborlist.txt").read().split()
    mycontext['identifier'] = str(ip) 
    for line in vessels:
      mycontext['vector_clock'][line] = 0
      if(ip != line):
        mycontext['vessels'].append((line,mycontext['port']))
        
  else:
    vessels = file("localports.txt").read().split()
    mycontext['identifier'] = str(port)
    for line in vessels:
      mycontext['vector_clock'][line] = 0
      if(str(port) != line):
        mycontext['vessels'].append((mycontext['ip'],line))
        

  #read html template files
  mycontext['entry_template'] = file("entry_template.html").read()
  mycontext['boardcontents_template'] = file("boardcontents_template.html").read()
  mycontext['frontpage_header_template'] = file("board_frontpage_header_template.html").read()
  mycontext['frontpage_footer_template'] = file("board_frontpage_footer_template.html").read()

  mycontext['authors'] = "sample author"

  start_board()
  
